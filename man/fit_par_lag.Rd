% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hhh4_new.R
\name{fit_par_lag}
\alias{fit_par_lag}
\title{Estimating the lag decay parameter of an \code{hhh4_lag} model using profile likelihood}
\usage{
fit_par_lag(
  stsObj,
  control,
  check.analyticals = FALSE,
  range_par,
  use_update = TRUE
)
}
\arguments{
\item{range_par}{a vector of values to try for the \code{par_lag} argument of \code{funct_lag}}

\item{use_update}{should results from previous values in range_par be used as starting value for next iteration (via \code{update})?}
}
\value{
A list including the best model among all fitted ones (\code{best_mod}) and a vector of the AIC values obtained for the different
values provided in \code{range_par} (\code{AICs})
}
\description{
Wrapper around \code{hhh4_lag} to allow for profile likelihood estimation of the scalar parameter
governing the lag structure. \code{hhh4_lag} can fit models with fixed lag decay parameter; \code{fit_par_lag} loops
around it and tries a set of possible parameters provided in the argument \code{range_par}. NOTE: this will
soon be replaced by \code{profile_par_lag} which does the same, but using \code{optim..., method = "Brent", ...)}.
}
\details{
In this modified version of \code{surveillance::hhh4}, distributed lags can be specified by
additional elements \code{control} argument:
\itemize{
  \item{\code{funct_lag}}{ Function to compute the lag weights \eqn{u_q} (see details) depending on a scalar
  parameter \code{par_lag}. The function has to take the
  following arguments:
  \itemize{
  \item{\code{par_lag}}{ A scalar parameter to steer \eqn{u_q}. It should be specified in a way which allows it to
  take any value in the real numbers}
  \item{\code{min_lag,max_lag}}{ Minimum and maximum lags; e.g. \code{min_lag = 3, max_lag = 6} will assign all weights to lags 3 through 6.
  Usually \code{min_lag} is set to 1, higher values can be useful for direct forecasting at higher horizons.}
  }}
  \item{\code{min_lag, max_lag}}{ Specification of the arguments passed to funct_lag} to compute the distributed lags. Unlike in
  \code{hhh4_lag}, \code{par_lag} is not to be specified as it is estimated from the data.
  Important: the first element of the \code{subset} argument in \code{control} needs to be larger than
  \code{max_lag} (as for the first \code{max_lag} observations the fitted values canot be computed)
}
Unlike in \code{hhh4_lag} the par_lag argument for \code{funct_lag} is not specified directly
by the user; instead the model is re-fit for each parameter value provided in \code{range_par}.

#' @param{stsObj,control,check.analyticals} As in \code{surveillance::hhh4}, but \code{control}
allows for some additional elements in order to specify a distributed lag structure:
\itemize{
  \item{\code{funct_lag}}{ Function to compute the lag weights \eqn{u_q} (see details) depending on a scalar
  parameter \code{par_lag}. The function has to take the
  following arguments:
  \itemize{
  \item{\code{par_lag}}{ A scalar parameter to steer \eqn{u_q}. It should be specified in a way which allows it to
  take any value in the real numbers}
  \item{\code{min_lag,max_lag}}{ Minimum and maximum lags; e.g. \code{min_lag = 3, max_lag = 6} will assign all weights to lags 3 through 6.
  Usually \code{min_lag} is set to 1, higher values can be useful for direct forecasting at higher horizons.}
  }}
  \item{\code{min_lag, max_lag}}{ Specification of the arguments passed to funct_lag} to compute the distributed lags. Unlike in
  \code{hhh4_lag}, \code{par_lag} is not to be specified as it is estimated from the data.
}
}
\examples{
## a simple univariate example:
data("salmonella.agona")
## convert old "disProg" to new "sts" data class
salmonella <- disProg2sts(salmonella.agona)
# specify and fit model: fixed geometric lag structure
control_salmonella <- list(end = list(f = addSeason2formula(~ 1)),
                           ar = list(f = addSeason2formula(~ 1)),
                           family = "NegBinM", subset = 6:312)
# get a reasonable range of values for par_lag. par_lag is logit(p) in teh
# geometric lag function
grid_p <- seq(from = 0.01, to = 0.99, by = 0.02)
grid_par_lag <- log(grid_p/(1 - grid_p))
fit_salmonella <- fit_par_lag(salmonella, control_salmonella, range_par = grid_par_lag)
summary(fit_salmonella$best_mod)
plot(fit_salmonella$AICs, xlab = "p", ylab = "AIC")
# 0.56 on first lag
#
# re-fit with Poisson lags:
control_salmonella2 <- control_salmonella
control_salmonella2$funct_lag = poisson_lag
grid_p2 <- seq(from = 0.01, to = 2, by = 0.02)
grid_par_lag2 <- log(grid_p2)
fit_salmonella2 <- fit_par_lag(salmonella, control_salmonella2, range_par = grid_par_lag2)
summary(fit_salmonella2$best_mod)
# leads to somewhat different decay and very slightly better AIC
}
\seealso{
\code{hhh4_lag} for fitting models with fixed \code{par_lag}; \code{profile_par_lag} for optimization using \code{optim}
rather than avector \code{range_par} of potential values.
}
